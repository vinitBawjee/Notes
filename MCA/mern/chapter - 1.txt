Introduction to Full Stack Development


    1.1 – Overview: Frontend, Backend, and Databases, Benefits of MERN

        1. What is Full Stack Development?
            Full Stack Development means developing both the frontend (client-side) and backend (server-side) parts of a web application, along with managing the database.

            In simple terms, a Full Stack Developer can build an entire web application — from what users see to how data is stored and processed.

        2. Frontend (Client-Side)
            Definition
                Frontend is the visible part of a website or web application that users interact with directly.

            Technologies Used
                HTML (HyperText Markup Language) – Structure of the web page
                CSS (Cascading Style Sheets) – Styling and layout
                JavaScript – Adds interactivity and logic
                Frontend Frameworks/Libraries: React.js, Angular, Vue.js

            Syntax Example (React Component)
                import React from 'react';

                function Welcome() {
                return (
                    <div>
                    <h1>Hello, Vinit!</h1>
                    <p>Welcome to Full Stack Development!</p>
                    </div>
                );
                }

                export default Welcome;

            Real-Life Example
                When you open Amazon, the product images, search bar, and “Add to Cart” button — all belong to the frontend.
                It’s built using HTML, CSS, and React.js.

        3. Backend (Server-Side)
            Definition
                Backend is the logic, database connection, and API part of the web app that runs on the server. It receives requests from the frontend, processes data, and sends a response back.

            Technologies Used
                Node.js (Runtime Environment)
                Express.js (Backend Framework)
                Python, Java, PHP (other languages possible)
                APIs (Application Programming Interfaces)

            Syntax Example (Express.js Server)
                import express from "express";
                const app = express();

                app.get("/api/welcome", (req, res) => {
                res.send("Welcome to Backend Server!");
                });

                app.listen(5000, () => {
                console.log("Server running on port 5000");
                });

            Real-Life Example
                When you click "Login" on Facebook, the backend verifies your credentials with the database and returns your user profile data.

        4. Database (Data Storage Layer)
            Definition
                A Database is where all the data (like users, products, messages, etc.) is stored, managed, and retrieved efficiently.

            Types of Databases
                SQL (Structured Query Language) – MySQL, PostgreSQL
                NoSQL (Non-relational) – MongoDB, Firebase

            Syntax Example (MongoDB Query)
                // Insert Data
                db.users.insertOne({ name: "Vinit", age: 21, course: "BCA" });

                // Fetch Data
                db.users.find({ name: "Vinit" });

            Real-Life Example
                When you place an order on Swiggy, the database stores your user ID, food items, restaurant name, and delivery address.

        5. How Frontend, Backend, and Database Work Together
            Flow:
                User interacts with Frontend (React App) → sends request
                Backend (Node + Express) receives request → processes it
                Database (MongoDB) is queried → sends back data
                Backend returns data → Frontend displays it to the user

            Example:
                User searches “Royal Enfield” →
                Frontend sends API call to /api/products →
                Backend fetches matching bikes from MongoDB →
                Frontend shows product list.

        6. Benefits of MERN Stack
            MERN = MongoDB + Express.js + React.js + Node.js

            | Layer             | Technology | Purpose                           |
            | ----------------- | ---------- | --------------------------------- |
            | Database          | MongoDB    | NoSQL Database                    |
            | Backend Framework | Express.js | Simplifies routing and middleware |
            | Frontend Library  | React.js   | Builds interactive UIs            |
            | Server Runtime    | Node.js    | Executes JavaScript on server     |

            Key Benefits
                Single Language (JavaScript)
                    - Both frontend and backend use JavaScript → easier to learn and manage.
                High Performance
                    - Node.js uses an event-driven, non-blocking model, making it fast.
                Scalability
                    - Ideal for large applications with real-time updates.
                Strong Community Support
                    - Each technology has a large community and ready-made libraries.
                JSON Everywhere
                    - Data is transferred in JSON format between frontend, backend, and database.
                Flexibility
                    - Components (React), APIs (Express), and documents (MongoDB) make development modular.

            Real-Life Use Cases of MERN Stack
                Netflix (React for UI, Node.js for backend)
                Uber Eats (real-time order tracking)
                Airbnb Clone projects by developers
                Social Media Apps, E-commerce Websites, Portfolio Websites

            Summary
                | Layer           | Technology           | Description         | Example         |
                | --------------- | -------------------- | ------------------- | --------------- |
                | Frontend        | React.js             | User Interface      | Login Page      |
                | Backend         | Node.js + Express.js | Logic + APIs        | Authentication  |
                | Database        | MongoDB              | Data Storage        | User Details    |
                | Overall Benefit | MERN Stack           | JS-based full-stack | Amazon-like App |

            Short Exam Points
                Full Stack Development → Both frontend & backend.
                Frontend → React.js handles UI.
                Backend → Node.js + Express handles APIs.
                Database → MongoDB stores data in JSON format.
                MERN Benefits → Single Language, Fast, Scalable, JSON-based.

    1.2 – Introduction to Component-Based Programming and SPA

        1. What is Component-Based Programming (CBP)?
            Definition
                Component-Based Programming (CBP) is a software development approach where an application is built by combining independent and reusable pieces of code called components.
            
                Each component represents a small, functional unit of the user interface — like a button, form, header, or card — which can be reused throughout the application.

        2. Key Features of Component-Based Programming
            | Feature             | Description                                                     |
            | ------------------- | --------------------------------------------------------------- |
            |   Reusability       | Components can be reused in multiple places.                    |
            |   Modularity        | Each component works independently.                             |
            |   Maintainability   | Easier to fix or update one component without affecting others. |
            |   Scalability       | New features can be added by creating new components.           |
            |   Testability       | Each component can be tested individually.                      |

        3. Example: React Component-Based Approach
            In React.js, everything is a component — even the entire webpage is made up of multiple small components.

            Component Hierarchy Example
                App Component
                │
                ├── Header Component
                ├── ProductList Component
                │     ├── ProductCard Component
                │
                └── Footer Component

            Syntax Example (Functional Components in React)
                import React from "react";

                // Header Component
                function Header() {
                return <h1>Welcome to Royal Enfield Store</h1>;
                }

                // ProductCard Component
                function ProductCard({ name, price }) {
                return (
                    <div className="card">
                    <h3>{name}</h3>
                    <p>Price: ₹{price}</p>
                    </div>
                );
                }

                // Main App Component
                function App() {
                return (
                    <div>
                    <Header />
                    <ProductCard name="Classic 350" price="1,90,000" />
                    <ProductCard name="Hunter 350" price="1,70,000" />
                    </div>
                );
                }

                export default App;

            Output:
                Welcome to Royal Enfield Store
                Classic 350 – ₹1,90,000
                Hunter 350 – ₹1,70,000

            Each component works independently and can be reused in other pages too.

        4. Real-Life Example of CBP
            Think of a Lego toy — each block (component) can be used to build many different structures.

            Similarly, in web apps:
                - Header, Sidebar, Button, Login Form, and Product Card are reusable components.
                - For example, YouTube has:
                - Navbar Component
                - VideoList Component
                - VideoCard Component
                - Sidebar Component

            All of these are reusable and maintainable.

        5. What is SPA (Single Page Application)?
            Definition
                A Single Page Application (SPA) is a type of web application that loads only one HTML page and dynamically updates content without refreshing the entire page.

                SPAs use AJAX or APIs to fetch data from the server and update the UI instantly.

        6. How SPA Works
            Traditional Website:
                - Every click → Sends a new request → Server sends a new HTML page → Full reload.

            SPA:
                - Only data is fetched using APIs.
                - The page does not reload, only specific components are updated.
                - Built using React.js, Angular, or Vue.js.

        7. Real-Life Example of SPA
            | Application  | SPA Behavior                                               |
            | ------------ | ---------------------------------------------------------- |
            |   Gmail      | Inbox, Sent, and Drafts change instantly — no page reload. |
            |   Facebook   | Clicking a post or profile updates content instantly.      |
            |   Netflix    | Movies load dynamically without full reload.               |

        8. SPA Example (React Router)
            Code Example:
                import { BrowserRouter as Router, Routes, Route, Link } from "react-router-dom";
                import Home from "./Home";
                import About from "./About";

                function App() {
                    return (
                        <Router>
                        <nav>
                            <Link to="/">Home</Link> | <Link to="/about">About</Link>
                        </nav>

                        <Routes>
                            <Route path="/" element={<Home />} />
                            <Route path="/about" element={<About />} />
                        </Routes>
                        </Router>
                    );
                }

                export default App;

            Output Behavior:
                - When clicking on Home or About, the page does not reload.
                - React updates the content dynamically → SPA behavior.

        9. Benefits of SPA
            | Benefit                            | Description                                               |
            | ---------------------------------- | --------------------------------------------------------- |
            |   Fast Loading                     | Loads only once, then fetches data dynamically.           |
            |   Smooth Navigation                | No page refresh → feels like a mobile app.                |
            |   Better User Experience           | Immediate response to user actions.                       |
            |   Reusable Components              | Reduces code duplication.                                 |
            |   Easier to Develop and Maintain   | Clear separation between UI (frontend) and API (backend). |

        10. Difference Between MPA and SPA
            | Feature                 | MPA (Multi Page App)             | SPA (Single Page App)           |
            | ----------------------- | -------------------------------- | ------------------------------- |
            |   Page Reload           | Reloads on every request         | Loads once, updates dynamically |
            |   Speed                 | Slower                           | Faster                          |
            |   Example               | Traditional websites (Wikipedia) | Modern apps (Gmail, React apps) |
            |   Frontend Frameworks   | JSP, PHP, ASP.NET                | React, Angular, Vue             |

        11. Real-World Use Case
            Imagine Swiggy:
                - When you click on "Restaurants" or "Orders", the page doesn’t reload.
                - It just updates the content instantly → this is SPA with reusable components built using React.js.

        12. Summary
            | Concept                           | Description                                    | Example                        |
            | --------------------------------- | ---------------------------------------------- | ------------------------------ |
            |   Component-Based Programming     | Building UI using independent, reusable blocks | React Components               |
            |   Single Page Application (SPA)   | Loads one page and updates dynamically         | Gmail, Facebook                |
            |   Main Benefit                    | Speed, modularity, reusability                 | Better UX and easy maintenance |

        13. Short Exam Points
            - CBP → Focuses on reusability & modularity.
            - SPA → Loads one page, dynamically updates data.
            - React.js → Best example of CBP + SPA framework.
            - Benefits → Faster, reusable, scalable, smooth UI.
            - Real-life Example → Gmail or Facebook SPA with components like Navbar, Feed, Chatbox.

    1.3 – Virtual DOM and JSX Compilation using Babel

        1. What is the DOM?
            Definition
                The DOM (Document Object Model) is a tree structure representation of an HTML document.
                It defines how HTML elements are accessed and manipulated by programming languages like JavaScript.

            Example
                <html>
                    <body>
                        <h1>Hello, Vinit!</h1>
                        <button>Click Me</button>
                    </body>
                </html>

                In the DOM, this becomes:

                Document
                └── html
                    └── body
                        ├── h1
                        └── button

        2. What is the Virtual DOM (VDOM)?
            Definition
                The Virtual DOM is a lightweight, virtual copy of the real DOM, used by libraries like React.js to optimize UI rendering.

                Instead of updating the real DOM directly (which is slow), React updates the Virtual DOM first, compares it with the previous version (using a process called diffing), and only updates the changed parts in the real DOM.

        3. How Virtual DOM Works (Step-by-Step)
            | Step   | Process                                                                                |
            | ------ | -------------------------------------------------------------------------------------- |
            |   1.   | React keeps a virtual copy of the real DOM in memory.                                  |
            |   2.   | When the state or props change, a new Virtual DOM is created.                          |
            |   3.   | React compares the **new VDOM** with the **previous VDOM** (diffing algorithm).        |
            |   4.   | Only the changed parts (differences) are updated in the **real DOM** (reconciliation). |

            Visual Example
                Old Virtual DOM: <h1>Hello</h1>
                New Virtual DOM: <h1>Hello Vinit!</h1>

                React finds that only the text inside <h1> has changed →
                So, it updates only that part of the real DOM instead of reloading the entire page.

        4. Code Example: How Virtual DOM Updates
            import React, { useState } from "react";

            function Counter() {
            const [count, setCount] = useState(0);

            return (
                <div>
                <h2>Count: {count}</h2>
                <button onClick={() => setCount(count + 1)}>Increase</button>
                </div>
            );
            }

            export default Counter;

            Explanation:
                - When you click the Increase button, only the <h2> element gets updated.
                - React does not re-render the entire page.
                - It updates only the part of the Virtual DOM that changed — count.

        5. Benefits of Virtual DOM
            | Benefit                      | Description                                        |
            | ---------------------------- | -------------------------------------------------- |
            |   Faster Performance         | Updates only changed elements, not the whole page. |
            |   Efficient Rendering        | Reduces unnecessary reflows/repaints in browser.   |
            |   Smooth User Experience     | UI feels instant and responsive.                   |
            |   Better Memory Management   | Updates happen in memory first, then in real DOM.  |

        6. JSX (JavaScript XML)
            Definition
                JSX is a syntax extension of JavaScript used in React to describe UI structure in a way that looks like HTML.

                JSX allows developers to write HTML-like code inside JavaScript files, making the code more readable and intuitive.

            Example of JSX
                const element = <h1>Hello, Vinit</h1>;

                This looks like HTML, but it’s actually JSX, which will later be compiled into JavaScript.

            Without JSX (Pure JavaScript)
                The same code without JSX would look like:
                const element = React.createElement("h1", null, "Hello, Vinit 👋");

                JSX is just syntactic sugar for React.createElement() calls.

        7. JSX Compilation using Babel
            What is Babel?
                Babel is a JavaScript compiler that converts modern JavaScript (ES6, JSX, etc.) into browser-compatible JavaScript (ES5).      

                React uses Babel to convert JSX code into pure JavaScript that browsers can understand.

            Example: JSX to JavaScript (via Babel)
                | JSX Code                                                         | Compiled JavaScript |
                | ---------------------------------------------------------------- | ------------------- |
                | ```jsx                                                           |                     |
                | const element = <h1>Hello Vinit!</h1>;                           |                     |
                | ```                                                              | ```js               |
                | const element = React.createElement("h1", null, "Hello Vinit!"); |                     |

                **Babel** automatically performs this conversion before execution.

                ---

                ### 🔹 **Babel Configuration Example (for a React project)**

                If you create a project manually (not with `create-react-app`), your `.babelrc` might look like:

                ```json
                {
                "presets": ["@babel/preset-env", "@babel/preset-react"]
                }

                This tells Babel to compile:
                    - Modern JS features (ES6 → ES5)
                    - React JSX → JavaScript

        8. Real-Life Example of Virtual DOM + JSX
            Imagine a chat application:
                - When a new message arrives, only the chat box area updates.
                - The header and sidebar remain unchanged.
                  That’s possible because of the Virtual DOM diffing process.

            The JSX defines how the UI looks:
                <div className="chat-box">
                    {messages.map((msg) => <p key={msg.id}>{msg.text}</p>)}
                </div>

            Babel compiles this JSX → efficient JavaScript → React uses Virtual DOM to update only new messages.

        9. Advantages of JSX
            | Advantage               | Description                                     |
            | ----------------------- | ----------------------------------------------- |
            |   Readability           | Looks like HTML, easier to understand.          |
            |   Faster Development    | Write UI and logic together in one file.        |
            |   Type Safety           | Catches errors at compile time (through Babel). |
            |   Integration with JS   | You can embed JS expressions easily using `{}`. |

            JS Expression in JSX Example
                const name = "Vinit";
                const element = <h2>Welcome, {name}!</h2>;

                Output: Welcome, Vinit!

        10. Summary
            | Concept          | Description                                      | Example                          |
            | ---------------- | ------------------------------------------------ | -------------------------------- |
            |   DOM            | Tree structure of HTML elements                  | `<div><h1>Hello</h1></div>`      |
            |   Virtual DOM    | In-memory representation for faster updates      | React updates changed parts only |
            |   JSX            | HTML-like syntax in JS                           | `<h1>Hello</h1>`                 |
            |   Babel          | Converts JSX/ES6 → ES5 for browsers              | `React.createElement()`          |
            |   Main Benefit   | Improves speed, readability, and maintainability | Used in React apps               |

        11. Short Exam & Interview Points
            Exam Points:
                - Virtual DOM is faster than Real DOM.
                - React uses Diffing and Reconciliation.
                - JSX → compiled to JavaScript by Babel.
                - Babel allows browsers to understand JSX.
                - JSX = React.createElement() syntax sugar.

            Interview Tips:
                Q: What is the Virtual DOM?
                A: It’s a virtual copy of the real DOM that React uses to perform efficient UI updates.

                Q: How does Babel help React?
                A: Babel compiles JSX and modern JavaScript into browser-compatible code.

                Q: Why is Virtual DOM faster?
                A: Because it updates only changed elements instead of re-rendering the whole DOM.

    1.4 – Introduction to ES6: const, let, and Arrow Functions

        1. What is ES6?
            Definition
                ES6 (ECMAScript 2015) is the 6th major version of JavaScript, introducing many modern features to make code cleaner, faster, and more readable.

                It improved the way variables are declared, how functions are written, and how objects and arrays are handled.

            Why ES6 is Important
                - Reduces code length
                - Increases readability
                - Introduces modern syntax (used in frameworks like React, Node.js)
                - Makes JavaScript more developer-friendly

        2. Variable Declaration: var, let, and const
            Before ES6, JavaScript used only var for variable declaration.
            Now, ES6 introduced let and const for better control and scope management.

            A. var (Old Way)
                - Function-scoped
                - Can be re-declared and updated
                - May cause unexpected bugs due to hoisting

                Example:
                    var name = "Vinit";
                    var name = "Bawjee"; // Re-declaration allowed
                    console.log(name); // Output: Bawjee

                Problem:
                    var does not respect block scope:

                    if (true) {
                    var x = 10;
                    }
                    console.log(x); // Output: 10 (still accessible outside the block)

            B. let (ES6 Feature)
                - Block-scoped
                - Can be updated but not re-declared in the same scope
                - Prevents many var-related bugs

                Example:
                    let city = "Mumbai";
                    city = "Pune"; // Updating allowed
                    console.log(city); // Output: Pune

                    let city = "Delhi"; // Error: Identifier 'city' has already been declared

                Block Scope Example:
                    if (true) {
                    let age = 21;
                    console.log(age); // Output: 21
                    }
                    console.log(age); // Error: age is not defined

                Real-life Example:
                    When creating a shopping cart, you might update let totalPrice as the user adds or removes items — but you don’t want to accidentally re-declare it.

            C. const (ES6 Feature)
                - Block-scoped
                - Cannot be re-assigned or re-declared
                - Must be initialized when declared
                - Ideal for constants and fixed references

                Example:
                    const appName = "Royal Enfield Store";
                    console.log(appName); // Output: Royal Enfield Store

                    appName = "Bike Store"; // Error: Assignment to constant variable

                However, for objects and arrays, the reference is constant — but internal values can change:
                    const user = { name: "Vinit", age: 21 };
                    user.age = 22; // Allowed
                    console.log(user); // Output: { name: "Vinit", age: 22 }

        3. Comparison Table: var vs let vs const
            | Feature            | var               | let                         | const                       |
            | ------------------ | ----------------- | --------------------------- | --------------------------- |
            |   Scope            | Function          | Block                       | Block                       |
            |   Re-declaration   | Yes               | No                          | No                          |
            |   Re-assignment    | Yes               | Yes                         | No                          |
            |   Hoisting         | Yes (undefined)   | Yes (but not initialized)   | Yes (but not initialized)   |
            |   Use Case         | Legacy code       | Variables that change       | Fixed values or references  |

        4. Arrow Functions (ES6 Feature)
            Definition
                Arrow functions provide a shorter and cleaner syntax to write functions.
                They are especially useful in callbacks, array methods, and React components.

            Old Way (Normal Function)
                function greet(name) {
                    return "Hello, " + name + "!";
                }
                console.log(greet("Vinit"));

            New Way (Arrow Function)
                const greet = (name) => "Hello, " + name + "!";
                console.log(greet("Vinit"));

                Output: Hello, Vinit!

        5. Arrow Function Syntax
            | Type                    | Syntax                  | Example                     |
            | ----------------------- | ----------------------- | --------------------------- |
            |   Single parameter      | `(param) => expression` | `name => console.log(name)` |
            |   Multiple parameters   | `(a, b) => a + b`       | `(x, y) => x * y`           |
            |   No parameters         | `() => expression`      | `() => "Welcome!"`          |
            |   Multiple lines        | `() => { ... }`         | `() => { return "Hello"; }` |

            Example 1: Add Two Numbers
                const add = (a, b) => a + b;
                console.log(add(10, 20)); // Output: 30

            Example 2: Using Arrow Function with Array
                const bikes = ["Hunter", "Classic", "Meteor"];
                bikes.forEach(bike => console.log("Bike:", bike));

            Output:
                Bike: Hunter
                Bike: Classic
                Bike: Meteor

            Example 3: Arrow Function in React Component
                const Welcome = () => {
                    return <h2>Hello Vinit! Welcome to React 🚀</h2>;
                };

                export default Welcome;

            This style is commonly used in functional components in React.

        6. Benefits of Arrow Functions
            | Benefit                    | Description                                            |
            | -------------------------- | ------------------------------------------------------ |
            |   Shorter Syntax           | No need for `function` keyword                         |
            |   Implicit Return          | Automatically returns expression if one-liner          |
            |   Lexical `this` Binding   | Inherits `this` from parent scope (important in React) |
            |   Cleaner Code             | Easier to read and maintain                            |

            Note on this in Arrow Functions
                Arrow functions do not have their own this — they use the this value from their parent scope.

            Example:
                function Bike() {
                    this.name = "Royal Enfield";
                    setTimeout(function() {
                        console.log(this.name); // undefined (normal function has its own this)
                    }, 1000);
                }

                function BikeArrow() {
                    this.name = "Hunter 350";
                    setTimeout(() => {
                        console.log(this.name); // Hunter 350 (arrow inherits parent this)
                    }, 1000);
                }

                new Bike();
                new BikeArrow();

        7. Real-Life Example
            Let’s say you are fetching user data in a React app:
            const getUserData = async () => {
                const response = await fetch("/api/users");
                const data = await response.json();
                console.log(data);
            };

            Why Arrow Function?
                - Cleaner syntax
                - Auto binds this
                - Perfect for React hooks, API calls, and event handlers

        8. Summary
            | Concept            | Definition                                  | Example                         |
            | ------------------ | ------------------------------------------- | ------------------------------- |
            |   let              | Block-scoped variable, can be reassigned    | `let count = 0;`                |
            |   const            | Block-scoped constant, cannot be reassigned | `const name = "Vinit";`         |
            |   Arrow Function   | Short syntax for writing functions          | `const greet = n => "Hi " + n;` |
            |   Key Benefit      | Cleaner, faster, modern code                | Used in React & Node.js         |

        9. Short Exam & Interview Points
            Exam Points:
                - let and const are block-scoped.
                - const cannot be reassigned.
                - Arrow functions provide concise syntax.
                - Babel converts ES6 → ES5 for compatibility.

            Interview Tips:
                Q: Difference between var, let, and const?
                A: var = function-scoped, let/const = block-scoped. const can’t be reassigned.

                Q: Why are arrow functions preferred in React?
                A: Shorter syntax and lexical this binding make them ideal for event handlers and hooks.

                Q: Can you reassign a const object?
                A: No, but you can modify its properties.

    1.5 – ES6 Classes, Promises, and Modules

        1. ES6 Classes
            Overview
                In ES6 (ECMAScript 2015), Classes were introduced to make Object-Oriented Programming (OOP) easier in JavaScript.
                Classes are templates for creating objects, just like in Java, C++, or Python.

                Before ES6, JavaScript used constructor functions for creating objects — classes provide a cleaner syntax.

            Syntax
                class Student {
                    constructor(name, course) {
                        this.name = name;
                        this.course = course;
                    }

                    displayInfo() {
                        return `${this.name} is studying ${this.course}`;
                    }
                }

                // Creating object
                const s1 = new Student("Vinit", "Full Stack Development");
                console.log(s1.displayInfo());

            Real-life Example
                Imagine you’re creating a web app where you manage users.
                A User class can define common properties like name, email, and methods for login/signup.

                class User {
                    constructor(username, email) {
                        this.username = username;
                        this.email = email;
                    }

                    login() {
                        console.log(`${this.username} logged in.`);
                    }

                    logout() {
                        console.log(`${this.username} logged out.`);
                    }
                }

                const user1 = new User("Vinit", "vinit@example.com");
                user1.login();

            Benefits:
                - Reusable structure
                - Inheritance support
                - Cleaner, more readable code

        2. Promises
            Overview
                A Promise is an object that represents the eventual completion (or failure) of an asynchronous operation.

                It helps avoid callback hell and makes async code easier to manage.

            Syntax
                const fetchData = new Promise((resolve, reject) => {
                    let success = true;
                    if (success) {
                        resolve("Data fetched successfully!");
                    } else {
                        reject("Error fetching data.");
                    }
                });

                fetchData
                .then((message) => console.log(message))
                .catch((error) => console.log(error))
                .finally(() => console.log("Process complete."));

            Real-life Example
                In a real web app, Promises are commonly used in API calls.

                fetch("https://jsonplaceholder.typicode.com/posts")
                .then(response => response.json())
                .then(data => console.log("Posts:", data))
                .catch(error => console.error("Error:", error));

            Benefits:
                - Handles asynchronous tasks (API calls, DB queries)
                - Cleaner than nested callbacks
                - Works well with async/await

        3. Modules
            Overview
                Modules allow you to split your code into multiple files — making it modular, reusable, and easy to maintain.
                Each module can export variables, functions, or classes and import them where needed.

            Syntax
                File: math.js
                export function add(a, b) {
                    return a + b;
                }

                export const PI = 3.14159;

                File: main.js
                import { add, PI } from './math.js';

                console.log("Sum:", add(5, 10));
                console.log("Value of PI:", PI);

            Real-life Example
                In a MERN app, you can have:
                    - database.js → handles MongoDB connection
                    - userController.js → handles user logic
                    - server.js → imports and runs everything

                // server.js
                import express from "express";
                import connectDB from "./database.js";

                const app = express();
                connectDB();
                app.listen(5000, () => console.log("Server running..."));

                Benefits:
                    - Code reusability
                    - Easier debugging
                    - Better team collaboration

            Summary Table
                | Concept      | Purpose                  | Example          | Real-life Use                        |
                | ------------ | ------------------------ | ---------------- | ------------------------------------ |
                |   Classes    | Define object blueprints | `class Car {}`   | Define models like `User`, `Product` |
                |   Promises   | Handle async operations  | `fetch().then()` | API calls, DB queries                |
                |   Modules    | Organize and reuse code  | `import/export`  | Split backend and frontend logic     |

